using Complex.ConsoleApp;
using CommandLine;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Concurrent;
using System.Text;

var totalComplexityText = CompositeFormat.Parse(Resources.TotalComplexity);
var fileComplexityText = CompositeFormat.Parse(Resources.FileComplexity);

Parser.Default.ParseArguments<Options>(args)
    .WithParsed(RunWithOptions)
    .WithNotParsed(errors => Environment.Exit(1));

return;

void RunWithOptions(Options opts)
{
    var inputFile = opts.InputFile;
    if (string.IsNullOrWhiteSpace(inputFile) || !(
            inputFile.EndsWith(".csproj", StringComparison.InvariantCultureIgnoreCase) ||
            inputFile.EndsWith(".sln", StringComparison.InvariantCultureIgnoreCase)))
    {
        Console.WriteLine(Resources.FileInputMissingOrInvalid);
        Environment.Exit(1);
    }

    var directory = Path.GetDirectoryName(Path.GetFullPath(inputFile)) ?? Directory.GetCurrentDirectory();
    var files = Directory.GetFiles(directory, "*.cs", SearchOption.AllDirectories)
        .Where(f =>
    #pragma warning disable CA1307
            !f.Contains($"{Path.DirectorySeparatorChar}bin{Path.DirectorySeparatorChar}") &&
            !f.Contains($"{Path.DirectorySeparatorChar}obj{Path.DirectorySeparatorChar}") &&
    #pragma warning restore CA1307
            !IsAutoGeneratedFile(f)
        ).ToArray();

    var complexityByNamespace = new ConcurrentDictionary<string, List<(string File, int Complexity, string Description)>>();
    var complexityByAssembly = new ConcurrentDictionary<string, List<(string File, int Complexity, string Description)>>();

    foreach (var file in files)
    {
        var code = File.ReadAllText(file);
        var tree = CSharpSyntaxTree.ParseText(code);
        var root = tree.GetRoot();

        var namespaceName = GetNamespace(root);
        var assemblyName = GetAssemblyName(file);
        var fileName = Path.GetFileName(file);

        var complexity = 0;
        var description = string.Empty;
        try
        {
            complexity = CodeMetricsCalculator.CalculateComplexity(code);

            complexityByNamespace.AddOrUpdate(
                namespaceName,
                [(fileName, complexity, description)],
                (_, list) => { list.Add((fileName, complexity, description)); return list; }
            );

            complexityByAssembly.AddOrUpdate(
                assemblyName,
                [(fileName, complexity, description)],
                (_, list) => { list.Add((fileName, complexity, description)); return list; }
            );
        }
    #pragma warning disable CA1031
        catch (Exception e)
    #pragma warning restore CA1031
        {
            description = e.Message;
        }
    }

    var threshold = opts.Threshold;
    var violationDetected = false;

    Console.WriteLine(Resources.ComplexityByNamespace);
    foreach (var ns in complexityByNamespace.OrderBy(x => x.Key))
    {
        Console.WriteLine(Resources.Namespace, ns.Key);
        Console.WriteLine(Resources.Dash);
        var totalComplexity = ns.Value.Sum(x => x.Complexity);
        var nsViolation = false;
        foreach (var file in ns.Value.OrderBy(x => x.File))
        {
            var fileViolationDetected = false;
            if (threshold.HasValue && file.Complexity > threshold.Value)
            {
                nsViolation = true;
                violationDetected = true;
                fileViolationDetected = true;
            }
            WriteFileSummary(file, fileViolationDetected);
        }
        WriteTotalSummary(totalComplexity, nsViolation);
    }

    Console.WriteLine(Resources.ComplexityByAssembly);
    foreach (var assembly in complexityByAssembly.OrderBy(x => x.Key))
    {
        Console.WriteLine(Resources.Assembly, assembly.Key);
        Console.WriteLine(Resources.Dash);
        var totalComplexity = assembly.Value.Sum(x => x.Complexity);
        var asmViolation = false;
        foreach (var file in assembly.Value.OrderBy(x => x.File))
        {
            var fileViolationDetected = false;
            if (threshold.HasValue && file.Complexity > threshold.Value)
            {
                asmViolation = true;
                violationDetected = true;
                fileViolationDetected = true;
            }
            WriteFileSummary(file, fileViolationDetected);
        }
        WriteTotalSummary(totalComplexity, asmViolation);
    }

    if (threshold.HasValue && violationDetected)
    {
        WriteLine($"[FAIL] One or more files exceeded the complexity threshold of {threshold.Value}.", ConsoleColor.Red);
        Environment.Exit(1);
    }
}

static string GetNamespace(SyntaxNode root)
{
    var namespaceDeclaration = root.DescendantNodes()
        .OfType<BaseNamespaceDeclarationSyntax>()
        .FirstOrDefault();
    return namespaceDeclaration?.Name.ToString() ?? "Global Namespace";
}

static string GetAssemblyName(string filePath)
{
    var projectDir = Path.GetDirectoryName(filePath);
    while (projectDir != null)
    {
        if (Directory.GetFiles(projectDir, "*.csproj").Length > 0)
        {
            return Path.GetFileName(projectDir);
        }
        projectDir = Path.GetDirectoryName(projectDir);
    }
    return "Unknown Assembly";
}

static bool IsAutoGeneratedFile(string filePath)
{
    var firstLines = File.ReadLines(filePath).Take(10).ToList();
    return firstLines.Any(line =>
        line.Contains("<auto-generated", StringComparison.InvariantCultureIgnoreCase) ||
        line.Contains("<autogenerated", StringComparison.InvariantCultureIgnoreCase) ||
        line.Contains("// <auto-generated>", StringComparison.InvariantCultureIgnoreCase) ||
        line.Contains("// <autogenerated>", StringComparison.InvariantCultureIgnoreCase)
    );
}

static void WriteLine(string message, ConsoleColor? color)
{
    if (color is null)
    {
        Console.WriteLine(message);
        return;
    }
    var originalColor = Console.ForegroundColor;
    Console.ForegroundColor = color.Value;
    Console.WriteLine(message);
    Console.ForegroundColor = originalColor;
}
void WriteFileSummary((string File, int Complexity, string Description) valueTuple, bool fileViolationDetected)
{
    var fileSummary = string.Format(
        System.Globalization.CultureInfo.InvariantCulture,
        fileComplexityText,
        valueTuple.File,
        valueTuple.Complexity,
        string.IsNullOrWhiteSpace(valueTuple.Description) ? string.Empty : valueTuple.Description);
    ConsoleColor? color = fileViolationDetected ? ConsoleColor.Yellow: null;
    WriteLine(fileSummary, color);
}
void WriteTotalSummary(int totalComplexity, bool summaryViolationDetected)
{
    var totalSummary = string.Format(
        System.Globalization.CultureInfo.InvariantCulture,
        totalComplexityText,
        totalComplexity);
    ConsoleColor? color = summaryViolationDetected ? ConsoleColor.Yellow : null;
    WriteLine(totalSummary, color);
}
