using Complex.ConsoleApp;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Concurrent;

var inputFile = args.Length > 0 ? args[0] : null;
if (inputFile is null || !(
        inputFile.EndsWith(".csproj", StringComparison.InvariantCultureIgnoreCase) ||
        inputFile.EndsWith(".sln", StringComparison.InvariantCultureIgnoreCase)))
{
    Console.WriteLine(Resources.FileInputMissingOrInvalid);
    return;
}

var directory = Path.GetDirectoryName(Path.GetFullPath(inputFile)) ?? Directory.GetCurrentDirectory();
var files = Directory.GetFiles(directory, "*.cs", SearchOption.AllDirectories)
    .Where(f =>
#pragma warning disable CA1307
        !f.Contains($"{Path.DirectorySeparatorChar}bin{Path.DirectorySeparatorChar}") &&
        !f.Contains($"{Path.DirectorySeparatorChar}obj{Path.DirectorySeparatorChar}") &&
#pragma warning restore CA1307
        !IsAutoGeneratedFile(f)
    ).ToArray();

var complexityByNamespace = new ConcurrentDictionary<string, List<(string File, int Complexity, string Description)>>();
var complexityByAssembly = new ConcurrentDictionary<string, List<(string File, int Complexity, string Description)>>();

foreach (var file in files)
{
    var code = File.ReadAllText(file);
    var tree = CSharpSyntaxTree.ParseText(code);
    var root = tree.GetRoot();

    var namespaceName = GetNamespace(root);
    var assemblyName = GetAssemblyName(file);
    var fileName = Path.GetFileName(file);

    var complexity = 0;
    var description = string.Empty;
    try
    {
        complexity = CodeMetricsCalculator.CalculateComplexity(code);

        complexityByNamespace.AddOrUpdate(
            namespaceName,
            [(fileName, complexity, description)],
            (_, list) => { list.Add((fileName, complexity, description)); return list; }
        );

        complexityByAssembly.AddOrUpdate(
            assemblyName,
            [(fileName, complexity, description)],
            (_, list) => { list.Add((fileName, complexity, description)); return list; }
        );
    }
#pragma warning disable CA1031
    catch (Exception e)
#pragma warning restore CA1031
    {
        description = e.Message;
    }
}

Console.WriteLine(Resources.ComplexityByNamespace);
foreach (var ns in complexityByNamespace.OrderBy(x => x.Key))
{
    Console.WriteLine(Resources.Namespace, ns.Key);
    Console.WriteLine(Resources.Dash);
    var totalComplexity = ns.Value.Sum(x => x.Complexity);
    foreach (var file in ns.Value.OrderBy(x => x.File))
    {
        Console.WriteLine(Resources.FileComplexity,
            file.File,
            file.Complexity,
            (string.IsNullOrWhiteSpace(file.Description) ? string.Empty : file.Description));
    }
    Console.WriteLine(Resources.TotalComplexity, totalComplexity);
}

Console.WriteLine(Resources.ComplexityByAssembly);
foreach (var assembly in complexityByAssembly.OrderBy(x => x.Key))
{
    Console.WriteLine(Resources.Assembly, assembly.Key);
    Console.WriteLine(Resources.Dash);
    var totalComplexity = assembly.Value.Sum(x => x.Complexity);
    foreach (var file in assembly.Value.OrderBy(x => x.File))
    {
        Console.WriteLine(Resources.FileComplexity,
            file.File,
            file.Complexity,
            (string.IsNullOrWhiteSpace(file.Description) ? string.Empty : file.Description));
    }
    Console.WriteLine(Resources.TotalComplexity, totalComplexity);
}

return;

static string GetNamespace(SyntaxNode root)
{
    var namespaceDeclaration = root.DescendantNodes()
        .OfType<BaseNamespaceDeclarationSyntax>()
        .FirstOrDefault();
    return namespaceDeclaration?.Name.ToString() ?? "Global Namespace";
}

static string GetAssemblyName(string filePath)
{
    var projectDir = Path.GetDirectoryName(filePath);
    while (projectDir != null)
    {
        if (Directory.GetFiles(projectDir, "*.csproj").Length > 0)
        {
            return Path.GetFileName(projectDir);
        }
        projectDir = Path.GetDirectoryName(projectDir);
    }
    return "Unknown Assembly";
}

static bool IsAutoGeneratedFile(string filePath)
{
    var firstLines = File.ReadLines(filePath).Take(10).ToList();
    return firstLines.Any(line =>
        line.Contains("<auto-generated", StringComparison.InvariantCultureIgnoreCase) ||
        line.Contains("<autogenerated", StringComparison.InvariantCultureIgnoreCase) ||
        line.Contains("// <auto-generated>", StringComparison.InvariantCultureIgnoreCase) ||
        line.Contains("// <autogenerated>", StringComparison.InvariantCultureIgnoreCase)
    );
}
