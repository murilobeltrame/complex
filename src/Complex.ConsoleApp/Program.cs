using System.Collections.Concurrent;
using Complex.ConsoleApp;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

var inputFile = args.Length > 0 ? args[0] : null;
if (inputFile is null || !(
        inputFile.EndsWith(".csproj", StringComparison.InvariantCultureIgnoreCase) ||
        inputFile.EndsWith(".sln", StringComparison.InvariantCultureIgnoreCase)))
{
    Console.WriteLine(Resources.FileInputMissingOrInvalid);
    return;
}
var directory = Path.GetDirectoryName(Path.GetFullPath(inputFile)) ?? Directory.GetCurrentDirectory();
var files = Directory.GetFiles(directory, "*.cs", SearchOption.AllDirectories)
    .Where(f =>
#pragma warning disable CA1307
        !f.Contains($"{Path.DirectorySeparatorChar}bin{Path.DirectorySeparatorChar}") &&
        !f.Contains($"{Path.DirectorySeparatorChar}obj{Path.DirectorySeparatorChar}") &&
#pragma warning restore CA1307
        !IsAutoGeneratedFile(f)
    ).ToArray();

var complexityByNamespace = new ConcurrentDictionary<string, List<(string File, int Complexity, string Description)>>();
var complexityByAssembly = new ConcurrentDictionary<string, List<(string File, int Complexity, string Description)>>();

foreach (var file in files)
{
    var code = File.ReadAllText(file);
    var fileName = Path.GetFileName(file);
    var tree = CSharpSyntaxTree.ParseText(code);
    var root = tree.GetRoot();

    var namespaceName = GetNamespace(root);
    var assemblyName = GetAssemblyName(file);

    var complexity = 0;
    var description = string.Empty;
    try
    {
        complexity = CodeMetricsCalculator.CalculateComplexity(code);

        complexityByNamespace.AddOrUpdate(
            namespaceName,
            new List<(string, int, string)> { (fileName, complexity, description) },
            (_, list) => { list.Add((fileName, complexity, description)); return list; }
        );

        complexityByAssembly.AddOrUpdate(
            assemblyName,
            new List<(string, int, string)> { (fileName, complexity, description) },
            (_, list) => { list.Add((fileName, complexity, description)); return list; }
        );
    }
#pragma warning disable CA1031
    catch (Exception e)
#pragma warning restore CA1031
    {
        description = e.Message;
    }

    Console.WriteLine($"{fileName} :: Cyclomatic Complexity: {complexity}. {(string.IsNullOrWhiteSpace(description) ? string.Empty : description)}");

    Console.WriteLine(Resources.ComplexityByNamespace);
    foreach (var ns in complexityByNamespace.OrderBy(x => x.Key))
    {
        Console.WriteLine($"\nNamespace: {ns.Key}");
        var totalComplexity = ns.Value.Sum(x => x.Complexity);
        foreach (var _file in ns.Value.OrderBy(x => x.File))
        {
            Console.WriteLine($"  {_file.File} :: Complexity: {_file.Complexity} {(string.IsNullOrWhiteSpace(_file.Description) ? string.Empty : _file.Description)}");
        }
        Console.WriteLine($"  Total Namespace Complexity: {totalComplexity}");
    }

    Console.WriteLine(Resources.ComplexityByAssembly);
    foreach (var assembly in complexityByAssembly.OrderBy(x => x.Key))
    {
        Console.WriteLine($"\nAssembly: {assembly.Key}");
        var totalComplexity = assembly.Value.Sum(x => x.Complexity);
        foreach (var _file in assembly.Value.OrderBy(x => x.File))
        {
            Console.WriteLine($"  {_file.File} :: Complexity: {_file.Complexity} {(string.IsNullOrWhiteSpace(_file.Description) ? string.Empty : _file.Description)}");
        }
        Console.WriteLine($"  Total Assembly Complexity: {totalComplexity}");
    }

    static string GetNamespace(SyntaxNode root)
    {
        var namespaceDeclaration = root.DescendantNodes()
            .OfType<BaseNamespaceDeclarationSyntax>()
            .FirstOrDefault();
        return namespaceDeclaration?.Name.ToString() ?? "Global Namespace";
    }

    static string GetAssemblyName(string filePath)
    {
        var projectDir = Path.GetDirectoryName(filePath);
        while (projectDir != null)
        {
            if (Directory.GetFiles(projectDir, "*.csproj").Length > 0)
            {
                return Path.GetFileName(projectDir);
            }
            projectDir = Path.GetDirectoryName(projectDir);
        }
        return "Unknown Assembly";
    }
}

static bool IsAutoGeneratedFile(string filePath)
{
    var firstLines = File.ReadLines(filePath).Take(10).ToList();
    return firstLines.Any(line =>
        line.Contains("<auto-generated", StringComparison.InvariantCultureIgnoreCase) ||
        line.Contains("<autogenerated", StringComparison.InvariantCultureIgnoreCase) ||
        line.Contains("// <auto-generated>", StringComparison.InvariantCultureIgnoreCase) ||
        line.Contains("// <autogenerated>", StringComparison.InvariantCultureIgnoreCase)
    );
}
